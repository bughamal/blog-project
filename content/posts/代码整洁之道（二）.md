+++ 
draft = true
date = 2020-12-20T13:24:37+08:00
title = "代码整洁之道（二）"
description = "代码整洁之道读书笔记整理"
slug = ""
authors = ["Chun Yi"]
tags = ["读书笔记","《代码整洁之道》"]
categories = ["读书笔记"]
externalLink = ""
series = ["代码整洁之道"]
+++

# 第7章 错误处理

## 7.5 依调用者需要定义异常类

异常分类有很多，当我们在应用程序中定义异常类时，最重要的考虑是他们如何被捕获。

先看一个不太好的异常分类的例子。下面的try-catch-finally语句是对某个第三方代码库的调用。

```java
ACMEPort port =new ACMEPort(12);
try{
    port.open();
} catch (DeviceResponseException e) {
    reportPortError(e);
    logger.log(Device response exception e);
} catch (ATM1212UnlockedException e) {
    reportPortError(e);
    logger.log(Unlock exception e);
} catch(GMXError e){
    reportPortError(e);
    logger.log(Device response exception);
} finally{
    ...
}
```

这对于调用第三方库来说并不出奇，因为我们总是要相对标准的处理异常和记录错误，但是这导致了大堆的重复代码。

我们可以通过打包调用API来简化代码，使其返回通用的异常类型。

```java
LocalPort port = new LocalPort(12);
try{
    port.open();
} catch (PortDeviceFailure e) {
    reportError(e) ;
    logger.log(e.getMessage (), e);
} finally {
    ...
}

//LocalPort类就是一个简单的打包类，它捕获并翻译异常
public class LocalPort{
    private ACMEPort innerPort;
    public LocalPort(int portNumber){
    innerPort = new ACMEPort(portNumber);

    public void open() {
    try {
        innerPort.open();
    } catch (DeviceResponseException e) {
        throw new PortDeviceFailure(e);
    } catch(ATM1212UnlockedException e) {
        throw new PortDeviceFailure(e);
    } catch(GMXError e){
        throw new PortDeviceFailure(e);
    }
```

## 7.6 定义常规流程

我们再来看一个不是很明智的代码：

```java
try {
    MealExpenses expenses =expenseReportDAO.getMeals(employee.getID());
    m_total +=expenses.getTotal();
} catch(MealExpensesNotFound e){
    m_total +=getMealPerDiem();
}
```

逻辑很简单：如果员工吃饭了，就加到总和中，要是没吃就发餐补。但是异常打断了业务逻辑。如果将代码改成下面这样👇：

```java
MealExpenses expenses=expenseReportDAO.getMeals(employee.getID());
m_total +=expenses.getTotal();
```

我们需要修改ExpenseReportDAO，使其总返回一个MealExpenses对象，不会出现null的情况。

```java
public class PerDiemMealExpenses implements MealExpenses{
public int getTotal(){
// return the per diem default
    }
}
```

如果没吃，就返回一个返回餐食补贴的MealExpense对象。

这种手法叫作特例模式（SPECIAL CASE PATTERN Fowler).创建一个类或配置一个
对象，用来处理特例。你来处理特例，客户代码就不用应对异常行为了。异常行为被封装到
特例对象中。

## 7.7 别返回null

下面是一个每行代码都在检查null的例子：

```java
public void registerItem(Item item){
    if (item !=null){
        ItemRegistry registry = peristentStore.getItemRegistry();
        if (registry !=null){
            Item existing =registry.getItem(item.getID());
            if (existing.getBillingPeriod().hasRetailOwner()){
                existing.register(item);
            }
        }
    }
}
```

**这种代码，只要有一处没有检查null，程序就会失控**

下面是一段不好的例子：

```java
List<Employee> employees = getEmployees();
if (employees !=null){
    for(Employee e:employees){
        totalPay +=e.getPay();
    }
}
```

如果修改getEmployees,返回空列表，就能使代码整洁起来：

```java
List<Employee> employees =getEmployees();
for(Employee e:employees) {
    totalPay +=e.getPay();
}
```

> 如果你在调用某个第三方API中
可能返回 nul1值的方法，可以考虑用新方法打包这个方法，在新方法中抛出异常或返回特例对象。

## 7.8 别传递null值

在方法中返回nul1值是糟糕的做法，将null值传递给其他方法就更糟糕了。除非API要求你向它传递null值，否则就要尽可能避免传递null值。

举个🌰：

```java
public class MetricsCalculator
{
    public double xProjection(Point p1,Point p2){
        return (p2.x-p1.x) * 1.5;
    }
    ...
}
```

如果有人传递null，肯定会得到一个空指针异常。

最常用的办法就是使用一组断言：

```java
public class MetricsCalculator
{
    public double xProjection(Point p1, Point p2){
        assert pl !=null:p1 should not be null;
        assert p2 !=null:p2 should not be null;
        return (p2.x-p1.x) * 1.5;
    }
}
```

看上去写的还行，但是问题还是没有解决，依然会运行错误。

**在大多数编程语言中，没有良好的方法能应付由调用者意外传入的null，恰当的做法就是禁止传入null值。这样，你在编码的时候，就会时刻记住参数列表中的null值意味着出问题了，从而大量避免这种无心之失。**

# 第9章 单元测试

## 9.1 TDD三定律

TDD要求我们在编写生产代码前先编写单元测试，他有三个定律。
- 第一定律：在编写不能通过的单元测试前，不可编写生产代码。
- 第二定律：只可编写刚好无法通过的单元测试，不能编译也算不通过。
- 第三定律：只可编写刚好足以通过当前失败测试的生产代码。

测试代码量足以匹敌生产代码量，导致令人生畏的管理问题。

## 9.2 保持测试整洁

### 测试带来的一切好处



## 9.3 整洁的测试

整洁的测试三大要素：**可读性、可读性和可读性**

测试如何才能做到可读性：和其他代码一样，**明确、简洁，并有足够的表达能力**。

下面是一段糟糕的测试代码，你不用读懂它，因为它真的很难读懂，也浪费时间。

![](../../static/代码整洁之道/代码清单9-1.jpg)
![](../../static/代码整洁之道2/代码清单9-1（2）.jpg)

读者会被淹没在细节的汪洋大海中，真正用到这些测试之前，还要裂解这些细节。

现在我们看看代码清单9-2：

![](../../static/代码整洁之道/代码清单9-2.jpg)